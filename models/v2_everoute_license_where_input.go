// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V2EverouteLicenseWhereInput v2 everoute license where input
//
// swagger:model V2EverouteLicenseWhereInput
type V2EverouteLicenseWhereInput struct {

	// a n d
	AND []*V2EverouteLicenseWhereInput `json:"AND,omitempty"`

	// n o t
	NOT []*V2EverouteLicenseWhereInput `json:"NOT,omitempty"`

	// o r
	OR []*V2EverouteLicenseWhereInput `json:"OR,omitempty"`

	// code
	Code *string `json:"code,omitempty"`

	// code contains
	CodeContains *string `json:"code_contains,omitempty"`

	// code ends with
	CodeEndsWith *string `json:"code_ends_with,omitempty"`

	// code gt
	CodeGt *string `json:"code_gt,omitempty"`

	// code gte
	CodeGte *string `json:"code_gte,omitempty"`

	// code in
	CodeIn []string `json:"code_in,omitempty"`

	// code lt
	CodeLt *string `json:"code_lt,omitempty"`

	// code lte
	CodeLte *string `json:"code_lte,omitempty"`

	// code not
	CodeNot *string `json:"code_not,omitempty"`

	// code not contains
	CodeNotContains *string `json:"code_not_contains,omitempty"`

	// code not ends with
	CodeNotEndsWith *string `json:"code_not_ends_with,omitempty"`

	// code not in
	CodeNotIn []string `json:"code_not_in,omitempty"`

	// code not starts with
	CodeNotStartsWith *string `json:"code_not_starts_with,omitempty"`

	// code starts with
	CodeStartsWith *string `json:"code_starts_with,omitempty"`

	// expire date
	ExpireDate *string `json:"expire_date,omitempty"`

	// expire date gt
	ExpireDateGt *string `json:"expire_date_gt,omitempty"`

	// expire date gte
	ExpireDateGte *string `json:"expire_date_gte,omitempty"`

	// expire date in
	ExpireDateIn []string `json:"expire_date_in,omitempty"`

	// expire date lt
	ExpireDateLt *string `json:"expire_date_lt,omitempty"`

	// expire date lte
	ExpireDateLte *string `json:"expire_date_lte,omitempty"`

	// expire date not
	ExpireDateNot *string `json:"expire_date_not,omitempty"`

	// expire date not in
	ExpireDateNotIn []string `json:"expire_date_not_in,omitempty"`

	// feature type
	FeatureType *EverouteFeatureType `json:"feature_type,omitempty"`

	// feature type in
	FeatureTypeIn []EverouteFeatureType `json:"feature_type_in,omitempty"`

	// feature type not
	FeatureTypeNot *EverouteFeatureType `json:"feature_type_not,omitempty"`

	// feature type not in
	FeatureTypeNotIn []EverouteFeatureType `json:"feature_type_not_in,omitempty"`

	// id
	ID *string `json:"id,omitempty"`

	// id contains
	IDContains *string `json:"id_contains,omitempty"`

	// id ends with
	IDEndsWith *string `json:"id_ends_with,omitempty"`

	// id gt
	IDGt *string `json:"id_gt,omitempty"`

	// id gte
	IDGte *string `json:"id_gte,omitempty"`

	// id in
	IDIn []string `json:"id_in,omitempty"`

	// id lt
	IDLt *string `json:"id_lt,omitempty"`

	// id lte
	IDLte *string `json:"id_lte,omitempty"`

	// id not
	IDNot *string `json:"id_not,omitempty"`

	// id not contains
	IDNotContains *string `json:"id_not_contains,omitempty"`

	// id not ends with
	IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`

	// id not in
	IDNotIn []string `json:"id_not_in,omitempty"`

	// id not starts with
	IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`

	// id starts with
	IDStartsWith *string `json:"id_starts_with,omitempty"`

	// max socket num
	MaxSocketNum *int32 `json:"max_socket_num,omitempty"`

	// max socket num gt
	MaxSocketNumGt *int32 `json:"max_socket_num_gt,omitempty"`

	// max socket num gte
	MaxSocketNumGte *int32 `json:"max_socket_num_gte,omitempty"`

	// max socket num in
	MaxSocketNumIn []int32 `json:"max_socket_num_in,omitempty"`

	// max socket num lt
	MaxSocketNumLt *int32 `json:"max_socket_num_lt,omitempty"`

	// max socket num lte
	MaxSocketNumLte *int32 `json:"max_socket_num_lte,omitempty"`

	// max socket num not
	MaxSocketNumNot *int32 `json:"max_socket_num_not,omitempty"`

	// max socket num not in
	MaxSocketNumNotIn []int32 `json:"max_socket_num_not_in,omitempty"`

	// max vcpu num
	MaxVcpuNum *int32 `json:"max_vcpu_num,omitempty"`

	// max vcpu num gt
	MaxVcpuNumGt *int32 `json:"max_vcpu_num_gt,omitempty"`

	// max vcpu num gte
	MaxVcpuNumGte *int32 `json:"max_vcpu_num_gte,omitempty"`

	// max vcpu num in
	MaxVcpuNumIn []int32 `json:"max_vcpu_num_in,omitempty"`

	// max vcpu num lt
	MaxVcpuNumLt *int32 `json:"max_vcpu_num_lt,omitempty"`

	// max vcpu num lte
	MaxVcpuNumLte *int32 `json:"max_vcpu_num_lte,omitempty"`

	// max vcpu num not
	MaxVcpuNumNot *int32 `json:"max_vcpu_num_not,omitempty"`

	// max vcpu num not in
	MaxVcpuNumNotIn []int32 `json:"max_vcpu_num_not_in,omitempty"`

	// max vm num
	MaxVMNum *int32 `json:"max_vm_num,omitempty"`

	// max vm num gt
	MaxVMNumGt *int32 `json:"max_vm_num_gt,omitempty"`

	// max vm num gte
	MaxVMNumGte *int32 `json:"max_vm_num_gte,omitempty"`

	// max vm num in
	MaxVMNumIn []int32 `json:"max_vm_num_in,omitempty"`

	// max vm num lt
	MaxVMNumLt *int32 `json:"max_vm_num_lt,omitempty"`

	// max vm num lte
	MaxVMNumLte *int32 `json:"max_vm_num_lte,omitempty"`

	// max vm num not
	MaxVMNumNot *int32 `json:"max_vm_num_not,omitempty"`

	// max vm num not in
	MaxVMNumNotIn []int32 `json:"max_vm_num_not_in,omitempty"`

	// max vpc socket num
	MaxVpcSocketNum *int32 `json:"max_vpc_socket_num,omitempty"`

	// max vpc socket num gt
	MaxVpcSocketNumGt *int32 `json:"max_vpc_socket_num_gt,omitempty"`

	// max vpc socket num gte
	MaxVpcSocketNumGte *int32 `json:"max_vpc_socket_num_gte,omitempty"`

	// max vpc socket num in
	MaxVpcSocketNumIn []int32 `json:"max_vpc_socket_num_in,omitempty"`

	// max vpc socket num lt
	MaxVpcSocketNumLt *int32 `json:"max_vpc_socket_num_lt,omitempty"`

	// max vpc socket num lte
	MaxVpcSocketNumLte *int32 `json:"max_vpc_socket_num_lte,omitempty"`

	// max vpc socket num not
	MaxVpcSocketNumNot *int32 `json:"max_vpc_socket_num_not,omitempty"`

	// max vpc socket num not in
	MaxVpcSocketNumNotIn []int32 `json:"max_vpc_socket_num_not_in,omitempty"`

	// pricing type
	PricingType *EverouteLicensePricingType `json:"pricing_type,omitempty"`

	// pricing type in
	PricingTypeIn []EverouteLicensePricingType `json:"pricing_type_in,omitempty"`

	// pricing type not
	PricingTypeNot *EverouteLicensePricingType `json:"pricing_type_not,omitempty"`

	// pricing type not in
	PricingTypeNotIn []EverouteLicensePricingType `json:"pricing_type_not_in,omitempty"`

	// serial
	Serial *string `json:"serial,omitempty"`

	// serial contains
	SerialContains *string `json:"serial_contains,omitempty"`

	// serial ends with
	SerialEndsWith *string `json:"serial_ends_with,omitempty"`

	// serial gt
	SerialGt *string `json:"serial_gt,omitempty"`

	// serial gte
	SerialGte *string `json:"serial_gte,omitempty"`

	// serial in
	SerialIn []string `json:"serial_in,omitempty"`

	// serial lt
	SerialLt *string `json:"serial_lt,omitempty"`

	// serial lte
	SerialLte *string `json:"serial_lte,omitempty"`

	// serial not
	SerialNot *string `json:"serial_not,omitempty"`

	// serial not contains
	SerialNotContains *string `json:"serial_not_contains,omitempty"`

	// serial not ends with
	SerialNotEndsWith *string `json:"serial_not_ends_with,omitempty"`

	// serial not in
	SerialNotIn []string `json:"serial_not_in,omitempty"`

	// serial not starts with
	SerialNotStartsWith *string `json:"serial_not_starts_with,omitempty"`

	// serial starts with
	SerialStartsWith *string `json:"serial_starts_with,omitempty"`

	// sign date
	SignDate *string `json:"sign_date,omitempty"`

	// sign date gt
	SignDateGt *string `json:"sign_date_gt,omitempty"`

	// sign date gte
	SignDateGte *string `json:"sign_date_gte,omitempty"`

	// sign date in
	SignDateIn []string `json:"sign_date_in,omitempty"`

	// sign date lt
	SignDateLt *string `json:"sign_date_lt,omitempty"`

	// sign date lte
	SignDateLte *string `json:"sign_date_lte,omitempty"`

	// sign date not
	SignDateNot *string `json:"sign_date_not,omitempty"`

	// sign date not in
	SignDateNotIn []string `json:"sign_date_not_in,omitempty"`

	// software edition
	SoftwareEdition *SoftwareEdition `json:"software_edition,omitempty"`

	// software edition in
	SoftwareEditionIn []SoftwareEdition `json:"software_edition_in,omitempty"`

	// software edition not
	SoftwareEditionNot *SoftwareEdition `json:"software_edition_not,omitempty"`

	// software edition not in
	SoftwareEditionNotIn []SoftwareEdition `json:"software_edition_not_in,omitempty"`

	// type
	Type *LicenseType `json:"type,omitempty"`

	// type in
	TypeIn []LicenseType `json:"type_in,omitempty"`

	// type not
	TypeNot *LicenseType `json:"type_not,omitempty"`

	// type not in
	TypeNotIn []LicenseType `json:"type_not_in,omitempty"`

	// uid
	UID *string `json:"uid,omitempty"`

	// uid contains
	UIDContains *string `json:"uid_contains,omitempty"`

	// uid ends with
	UIDEndsWith *string `json:"uid_ends_with,omitempty"`

	// uid gt
	UIDGt *string `json:"uid_gt,omitempty"`

	// uid gte
	UIDGte *string `json:"uid_gte,omitempty"`

	// uid in
	UIDIn []string `json:"uid_in,omitempty"`

	// uid lt
	UIDLt *string `json:"uid_lt,omitempty"`

	// uid lte
	UIDLte *string `json:"uid_lte,omitempty"`

	// uid not
	UIDNot *string `json:"uid_not,omitempty"`

	// uid not contains
	UIDNotContains *string `json:"uid_not_contains,omitempty"`

	// uid not ends with
	UIDNotEndsWith *string `json:"uid_not_ends_with,omitempty"`

	// uid not in
	UIDNotIn []string `json:"uid_not_in,omitempty"`

	// uid not starts with
	UIDNotStartsWith *string `json:"uid_not_starts_with,omitempty"`

	// uid starts with
	UIDStartsWith *string `json:"uid_starts_with,omitempty"`

	// version
	Version *int32 `json:"version,omitempty"`

	// version gt
	VersionGt *int32 `json:"version_gt,omitempty"`

	// version gte
	VersionGte *int32 `json:"version_gte,omitempty"`

	// version in
	VersionIn []int32 `json:"version_in,omitempty"`

	// version lt
	VersionLt *int32 `json:"version_lt,omitempty"`

	// version lte
	VersionLte *int32 `json:"version_lte,omitempty"`

	// version not
	VersionNot *int32 `json:"version_not,omitempty"`

	// version not in
	VersionNotIn []int32 `json:"version_not_in,omitempty"`
}

// Validate validates this v2 everoute license where input
func (m *V2EverouteLicenseWhereInput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAND(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNOT(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOR(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeatureType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeatureTypeIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeatureTypeNot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeatureTypeNotIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePricingType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePricingTypeIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePricingTypeNot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePricingTypeNotIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareEdition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareEditionIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareEditionNot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareEditionNotIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeNot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeNotIn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V2EverouteLicenseWhereInput) validateAND(formats strfmt.Registry) error {
	if swag.IsZero(m.AND) { // not required
		return nil
	}

	for i := 0; i < len(m.AND); i++ {
		if swag.IsZero(m.AND[i]) { // not required
			continue
		}

		if m.AND[i] != nil {
			if err := m.AND[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AND" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("AND" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateNOT(formats strfmt.Registry) error {
	if swag.IsZero(m.NOT) { // not required
		return nil
	}

	for i := 0; i < len(m.NOT); i++ {
		if swag.IsZero(m.NOT[i]) { // not required
			continue
		}

		if m.NOT[i] != nil {
			if err := m.NOT[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("NOT" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("NOT" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateOR(formats strfmt.Registry) error {
	if swag.IsZero(m.OR) { // not required
		return nil
	}

	for i := 0; i < len(m.OR); i++ {
		if swag.IsZero(m.OR[i]) { // not required
			continue
		}

		if m.OR[i] != nil {
			if err := m.OR[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("OR" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("OR" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateFeatureType(formats strfmt.Registry) error {
	if swag.IsZero(m.FeatureType) { // not required
		return nil
	}

	if m.FeatureType != nil {
		if err := m.FeatureType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateFeatureTypeIn(formats strfmt.Registry) error {
	if swag.IsZero(m.FeatureTypeIn) { // not required
		return nil
	}

	for i := 0; i < len(m.FeatureTypeIn); i++ {

		if err := m.FeatureTypeIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateFeatureTypeNot(formats strfmt.Registry) error {
	if swag.IsZero(m.FeatureTypeNot) { // not required
		return nil
	}

	if m.FeatureTypeNot != nil {
		if err := m.FeatureTypeNot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateFeatureTypeNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.FeatureTypeNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.FeatureTypeNotIn); i++ {

		if err := m.FeatureTypeNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validatePricingType(formats strfmt.Registry) error {
	if swag.IsZero(m.PricingType) { // not required
		return nil
	}

	if m.PricingType != nil {
		if err := m.PricingType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validatePricingTypeIn(formats strfmt.Registry) error {
	if swag.IsZero(m.PricingTypeIn) { // not required
		return nil
	}

	for i := 0; i < len(m.PricingTypeIn); i++ {

		if err := m.PricingTypeIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validatePricingTypeNot(formats strfmt.Registry) error {
	if swag.IsZero(m.PricingTypeNot) { // not required
		return nil
	}

	if m.PricingTypeNot != nil {
		if err := m.PricingTypeNot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validatePricingTypeNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.PricingTypeNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.PricingTypeNotIn); i++ {

		if err := m.PricingTypeNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateSoftwareEdition(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareEdition) { // not required
		return nil
	}

	if m.SoftwareEdition != nil {
		if err := m.SoftwareEdition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateSoftwareEditionIn(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareEditionIn) { // not required
		return nil
	}

	for i := 0; i < len(m.SoftwareEditionIn); i++ {

		if err := m.SoftwareEditionIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateSoftwareEditionNot(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareEditionNot) { // not required
		return nil
	}

	if m.SoftwareEditionNot != nil {
		if err := m.SoftwareEditionNot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateSoftwareEditionNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareEditionNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.SoftwareEditionNotIn); i++ {

		if err := m.SoftwareEditionNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateTypeIn(formats strfmt.Registry) error {
	if swag.IsZero(m.TypeIn) { // not required
		return nil
	}

	for i := 0; i < len(m.TypeIn); i++ {

		if err := m.TypeIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateTypeNot(formats strfmt.Registry) error {
	if swag.IsZero(m.TypeNot) { // not required
		return nil
	}

	if m.TypeNot != nil {
		if err := m.TypeNot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) validateTypeNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.TypeNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.TypeNotIn); i++ {

		if err := m.TypeNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this v2 everoute license where input based on the context it is used
func (m *V2EverouteLicenseWhereInput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAND(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNOT(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOR(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatureType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatureTypeIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatureTypeNot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatureTypeNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePricingType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePricingTypeIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePricingTypeNot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePricingTypeNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareEdition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareEditionIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareEditionNot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareEditionNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTypeIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTypeNot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTypeNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateAND(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AND); i++ {

		if m.AND[i] != nil {
			if err := m.AND[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AND" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("AND" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateNOT(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NOT); i++ {

		if m.NOT[i] != nil {
			if err := m.NOT[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("NOT" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("NOT" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateOR(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OR); i++ {

		if m.OR[i] != nil {
			if err := m.OR[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("OR" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("OR" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateFeatureType(ctx context.Context, formats strfmt.Registry) error {

	if m.FeatureType != nil {
		if err := m.FeatureType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateFeatureTypeIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FeatureTypeIn); i++ {

		if err := m.FeatureTypeIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateFeatureTypeNot(ctx context.Context, formats strfmt.Registry) error {

	if m.FeatureTypeNot != nil {
		if err := m.FeatureTypeNot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateFeatureTypeNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FeatureTypeNotIn); i++ {

		if err := m.FeatureTypeNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature_type_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature_type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidatePricingType(ctx context.Context, formats strfmt.Registry) error {

	if m.PricingType != nil {
		if err := m.PricingType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidatePricingTypeIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PricingTypeIn); i++ {

		if err := m.PricingTypeIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidatePricingTypeNot(ctx context.Context, formats strfmt.Registry) error {

	if m.PricingTypeNot != nil {
		if err := m.PricingTypeNot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidatePricingTypeNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PricingTypeNotIn); i++ {

		if err := m.PricingTypeNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pricing_type_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pricing_type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateSoftwareEdition(ctx context.Context, formats strfmt.Registry) error {

	if m.SoftwareEdition != nil {
		if err := m.SoftwareEdition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateSoftwareEditionIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SoftwareEditionIn); i++ {

		if err := m.SoftwareEditionIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateSoftwareEditionNot(ctx context.Context, formats strfmt.Registry) error {

	if m.SoftwareEditionNot != nil {
		if err := m.SoftwareEditionNot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateSoftwareEditionNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SoftwareEditionNotIn); i++ {

		if err := m.SoftwareEditionNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateTypeIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TypeIn); i++ {

		if err := m.TypeIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateTypeNot(ctx context.Context, formats strfmt.Registry) error {

	if m.TypeNot != nil {
		if err := m.TypeNot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_not")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type_not")
			}
			return err
		}
	}

	return nil
}

func (m *V2EverouteLicenseWhereInput) contextValidateTypeNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TypeNotIn); i++ {

		if err := m.TypeNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_not_in" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V2EverouteLicenseWhereInput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V2EverouteLicenseWhereInput) UnmarshalBinary(b []byte) error {
	var res V2EverouteLicenseWhereInput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
